/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ec.nbdemetra.ui;

import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimaps;
import demetra.ui.nodes.AbstractNodeBuilder;
import ec.nbdemetra.ui.nodes.IdNodes;
import demetra.ui.properties.NodePropertySetBuilder;
import ec.ui.view.tsprocessing.ProcDocumentItemFactory;
import ec.ui.view.tsprocessing.ProcDocumentItemFactoryLoader;
import java.awt.Image;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import javax.swing.DefaultComboBoxModel;
import javax.swing.Icon;
import org.openide.explorer.ExplorerManager;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.nodes.Sheet;
import org.openide.util.ImageUtilities;
import org.openide.util.lookup.Lookups;

final class ProcDocumentItemsPanel extends javax.swing.JPanel implements ExplorerManager.Provider {

    private final ProcDocumentItemsOptionsPanelController controller;
    final ExplorerManager em;

    ProcDocumentItemsPanel(ProcDocumentItemsOptionsPanelController controller) {
        this.controller = controller;
        this.em = new ExplorerManager();
        initComponents();

        outlineView1.getOutline().setRootVisible(false);
        jComboBox1.setModel(new DefaultComboBoxModel(NodeStrategies.values()));
        jComboBox1.setSelectedIndex(0);
        jComboBox1.addItemListener(event -> load());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        outlineView1 = new org.openide.explorer.view.OutlineView();
        jComboBox1 = new javax.swing.JComboBox();

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(outlineView1, javax.swing.GroupLayout.DEFAULT_SIZE, 458, Short.MAX_VALUE)
            .addComponent(jComboBox1, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(outlineView1, javax.swing.GroupLayout.DEFAULT_SIZE, 374, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public ExplorerManager getExplorerManager() {
        return em;
    }

    void load() {
        Iterable<? extends ProcDocumentItemFactory> all = ProcDocumentItemFactoryLoader.get();
        NodeStrategies strategies = ((NodeStrategies) jComboBox1.getSelectedItem());
        em.setRootContext(strategies.getRoot(all));
        outlineView1.setPropertyColumns(strategies.getPropertyColumns());
    }

    void store() {
    }

    boolean valid() {
        return true;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox jComboBox1;
    private org.openide.explorer.view.OutlineView outlineView1;
    // End of variables declaration//GEN-END:variables

    enum NodeStrategies {

        FLAT_LAYOUT {
            @Override
            public Node getRoot(Iterable<? extends ProcDocumentItemFactory> factories) {
                return new AbstractNodeBuilder()
                        .name("Items")
                        .add(StreamSupport.stream(factories.spliterator(), false).map(o -> new ProcDocumentItemFactoryNode(o)))
                        .build();
            }

            @Override
            public String[] getPropertyColumns() {
                return new String[]{"DocumentType", "Document Type"};
            }
        },
        GROUP_BY_DOCUMENT_TYPE {
            @Override
            public Node getRoot(Iterable<? extends ProcDocumentItemFactory> factories) {
                ImmutableMultimap<Class<?>, ? extends ProcDocumentItemFactory> index = Multimaps.index(factories, o -> o.getDocumentType());

                AbstractNodeBuilder result = new AbstractNodeBuilder().name("Items");
                for (Class<?> o : index.keySet()) {
                    Stream<Node> children = StreamSupport.stream(index.get(o).spliterator(), false).map(x -> new ProcDocumentItemFactoryNode(x));
                    result.add(new AbstractNodeBuilder().name(o.getName()).add(children).build());
                }
                return result.build();
            }

            @Override
            public String[] getPropertyColumns() {
                return new String[0];
            }
        },
        GROUP_BY_DOCUMENT_TYPE_AND_ID {
            @Override
            public Node getRoot(Iterable<? extends ProcDocumentItemFactory> factories) {
                ImmutableMultimap<Class<?>, ? extends ProcDocumentItemFactory> index = Multimaps.index(factories, o -> o.getDocumentType());

                AbstractNodeBuilder result = new AbstractNodeBuilder().name("Items");
                for (Class<?> o : index.keySet()) {
                    Node tmp = IdNodes.getRootNode(index.get(o).stream().map(x -> x.getItemId()).collect(Collectors.toList()));
                    tmp.setName(o.getName());
                    result.add(tmp);
                }
                return result.build();
            }

            @Override
            public String[] getPropertyColumns() {
                return new String[0];
            }
        };

        abstract public Node getRoot(Iterable<? extends ProcDocumentItemFactory> factories);

        abstract public String[] getPropertyColumns();
    }

    static class ProcDocumentItemFactoryNode extends AbstractNode {

        public ProcDocumentItemFactoryNode(ProcDocumentItemFactory factory) {
            super(Children.LEAF, Lookups.singleton(factory));
            setName(factory.getItemId().toString());
//            setDisplayName(factory.getItemId().tail());
        }

        @Override
        public Image getIcon(int type) {
            ProcDocumentItemFactory factory = getLookup().lookup(ProcDocumentItemFactory.class);
            Icon result = factory.getIcon();
            return ImageUtilities.icon2Image(result != null ? result : new IdNodes.IdIcon(factory.getItemId()));
        }

        @Override
        public Image getOpenedIcon(int type) {
            return getIcon(type);
        }

        @Override
        protected Sheet createSheet() {
            ProcDocumentItemFactory factory = getLookup().lookup(ProcDocumentItemFactory.class);
            Sheet result = super.createSheet();
            NodePropertySetBuilder b = new NodePropertySetBuilder();
            b.with(Class.class)
                    .select(factory, "getDocumentType", null)
                    .name("DocumentType")
                    .display("Document Type")
                    .add();
            result.put(b.build());
            return result;
        }
    }
}
